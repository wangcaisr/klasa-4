<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Porównanie programowania
        obiektowego i strukturalnego.</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<header>
    <h1>zasady programowania</h1>
    <h2>autor: piotr sadurski</h2>
    <hr>
    <section>
        <h2>Programowanie strukturalne</h2>
        <li>Paradygmat programowania zakładający rozdzielenie
            funkcjonalności programu na moduły (podprogramy).
            Komunikują się one ze sobą przez określone interfejsy.</li>
        <li>Jest rozszerzeniem programowania proceduralnego
            (poprawa przejrzystości i jakości kodu oraz
            przyśpieszenie tworzenia oprogramowania).</li>
        <hr>
        <h2>Założenia programowania strukturalnego</h2>
        <li>Podzielone bloki kodu mają jeden punkt wejścia (mogą
            mieć wiele punktów wyjścia)</li>
        <li>Wykonywanie wyrażeń w określonej kolejności</li>
        <li>Używanie instrukcji warunkowych (if , if else)</li>
        <li>Używanie pętli (for, while, do while)</li>
        <li>Unikanie instrukcji skoku (goto)</li>
        <li>Unikanie instrukcji break, continue</li>
        <hr>
        <h2>Programowanie obiektowe</h2>
        <li>Paradygmat programowania zakładający reprezentację
            problemów w postaci obiektów, przypisanie im działań
            (metod), które mogą wykonywać oraz umieszczenie pól,
            które opisują dany obiekt.</li>
        <li>Jest to podejście bardziej naturalne dla ludzi, bardziej
            zgodne z rzeczywistością.</li>
        <hr>
        <h2>Założenia programowania obiektowego</h2>
        <li>Abstrakcja</li>
        <li>Hermetyzacja danych (enkapsulacja)</li>
        <li>Dziedziczenie</li>
        <li>Polimorfizm</li>
        <hr>
        <h2>Abstrakcja</h2>
        <li>Zredukowanie właściwości opisywanego obiektu do
            najbardziej podstawowych, ograniczenie zakresu
            funkcjonalności obiektu do kluczowych dla danego
            zagadnienia działań.</li>
        <li>Ukrycie funkcjonalności za interfejsem, uogólnienie
            implementacji.</li>
        <hr>
        <h2>Enkapsulacja</h2>
        <li>Inaczej hermetyzacja danych.</li>
        <li>Dostęp do składowych jest ograniczony za pomocą
            dobrze określonego interfejsu, czyli obiekt udostępnia
            tylko pewien zbiór metod, które są widoczne z zewnątrz i
            mogą być wywoływane.</li>
        <li>Dostęp do pól obiektu powinien być realizowany poprzez
            odpowiednie metody(Settery/gettery) a nie przez
            bezpośredni dostęp do nich.</li>
        <hr>
        <h2>Dziedziczenie</h2>
        <li>Mechanizm umożliwiający wywodzenie nowych klas z klas
            już istniejących, wraz z przejmowaniem ich metod. Dzięki
            czemu zyskujemy wszystkie już istniejące funkcjonalności,
            które dodatkowo możemy rozszerzyć lub zmienić.</li>
        <hr>
        <h2>Polimorfizm</h2>
        <li>Mechanizm pozwalający na używanie metod itp. na różny
            sposób, np. przeciążając metodę toString, aby akceptowała
            zmienne typu int, float, decimal i każdą z nich
            konwertowała właściwie do ciągu znakowego.</li>
        <hr>
        <h2>Różnice</h2>
        <li>W programowaniu strukturalnym mamy podprogramy
            (funkcje), które odpowiednio ułożone i wywołane tworzą
            program.</li>
        <li>Natomiast w p. obiektowym funkcjonalności są
            przypisane obiektom, zatem trudniej tutaj o pomyłkę np.
            taką jak przekazanie złej zmiennej do funkcji.</li>
    </section>
</header>
</body>
</html>